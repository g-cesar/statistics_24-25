<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cryptography analyzer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.7.0/chart.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chartjs-plugin-datalabels/2.2.0/chartjs-plugin-datalabels.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        canvas#background {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            background-color: #000;
        }
    
        .glassCard{
            background: rgba(255, 255, 255, 0.2);
            border-radius: 16px;
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.3);
            height: max-content;
        }
  
        .glassChart{
          background: rgba(0, 0, 0, 0.85);
          border-radius: 16px;
          box-shadow: 0 4px 30px rgba(0, 0, 0, 0.1);
          border: 1px solid rgba(255, 255, 255, 0.3);
          height: calc(max-content + 2rem);
      }
    
        .glassHeader{
            background: rgba(0, 132, 255, 0.2);
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.3);
            height: max-content;
        }
    </style>
</head>
<body class="h-svh">
    <nav class="glassHeader w-full fixed top-0 start-0 z-10">
        <div class="max-w-screen-xl flex flex-wrap items-center justify-between mx-auto p-4">
          <a href="#" class="text-white">
            <h1 class="text-3xl font-bold">Guido Cesarano - 1803991</h1>
            <h2 class="text-2xl font-semibold">Statistics Course a.a. 24/25</h2>
          </a>
        </div>
    </nav>
    <canvas id="background"></canvas>
    <main class="mt-32 mb-4 mx-4">
        <div class="glassCard shadow rounded-lg p-8">
            <h1 class="text-2xl font-bold text-white text-center">Cryptography Analyzer</h1>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                <div class="flex justify-center flex-col">
                    <div class="mb-4">
                        <label class="block text-sm font-medium text-white mb-2">Select Encryption Method:</label>
                        <select id="encryptionMethod" class="bg-gray-50 border border-gray-300 text-blue-600 text-sm rounded-lg focus:ring-white focus:border-white block w-full p-2.5">
                            <option value="caesar">Caesar Cipher</option>
                            <option value="modexp">Modular Exponential Cipher</option>
                        </select>
                    </div>
                    <div id="cipherParameters" class="mb-4">
                        <!-- Parameters will be dynamically added here -->
                    </div>
                    <textarea 
                        id="originalText" 
                        class="w-full mt-4 h-24 p-4 border border-gray-300 rounded-md focus:ring-2 focus:ring-white focus:border-white"
                        placeholder="Enter text to encrypt..."
                    ></textarea>
                    <button 
                        onclick="processText()" 
                        class="text-blue-600 bg-white hover:bg-blue-100 focus:ring-4 focus:ring-blue-300 font-medium rounded-lg text-sm px-5 py-2.5 mt-4"
                    >
                        Analyze and Encrypt
                    </button>
                </div>
                <div class="mt-6 h-[300px]">
                    <canvas class="glassChart" id="originalChart"></canvas>
                </div>
            </div>
        </div>
        <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mt-4">
            <div class="glassCard shadow rounded-lg shadow-md p-6">
                <h2 class="text-2xl font-semibold text-white mb-4">Encrypted Text</h2>
                <div id="encryptedText" class="p-4 bg-gray-50 rounded-md text-gray-700"></div>
            </div>
            <div class="glassCard shadow rounded-lg shadow-md p-6">
                <h2 class="text-2xl font-semibold text-white mb-4">Frequency distribution of the encrypted text</h2>
                <div class="mt-6 h-[300px]">
                    <canvas class="glassChart" id="encryptedChart"></canvas>
                </div>
            </div>
        </div>
        <div class="glassCard shadow rounded-lg shadow-md my-4 p-6">
            <h2 class="text-2xl font-semibold text-white mb-4">Decryption attempt</h2>
            <div id="decryptedText" class="font-mono p-4 bg-gray-50 rounded-md text-gray-700"></div>
        </div>
    </main>

    <script>
        
        // Calcolo della potenza modulare (N^k % P)
        function modPow(base, exponent, modulus) {
            if (modulus === 1) return 0;
            
            let result = 1;
            base = base % modulus;
            
            while (exponent > 0) {
                if (exponent % 2 === 1) {
                    result = (result * base) % modulus;
                }
                base = (base * base) % modulus;
                exponent = Math.floor(exponent / 2);
            }
            
            return result;
        }

        // Calcolo dell'inverso moltiplicativo mod P
        // Algoritmo esteso di Euclide per calcolare l'inverso modulo
        function modInverse(a, m) {
            let m0 = m;
            let x0 = 0;
            let x1 = 1;
            
            if (m == 1) return 0;
            
            while (a > 1) {
                let q = Math.floor(a / m);
                let t = m;
                
                m = a % m;
                a = t;
                t = x0;
                
                x0 = x1 - q * x0;
                x1 = t;
            }
            
            if (x1 < 0) x1 += m0;
            
            return x1;
        }

        function updateParameters() {
            const method = document.getElementById('encryptionMethod').value;
            const container = document.getElementById('cipherParameters');
            container.innerHTML = '';

            if (method === 'caesar') {
                container.innerHTML = `
                    <label class="block text-sm font-medium text-white mb-2">Shift (1-25):</label>
                    <input type="number" id="shift" min="1" max="25" value="${Math.floor(Math.random() * 25) + 1}" 
                           class="bg-gray-50 border border-gray-300 text-gray-900 text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 block w-full p-2.5">
                `;
            } else if (method === 'modexp') {
                container.innerHTML = `
                    <div class="grid grid-cols-3 gap-4">
                        <div>
                            <label class="block text-sm font-medium text-white mb-2">Base (N):</label>
                            <input type="number" id="base" value="2" 
                                   class="bg-gray-50 border border-gray-300 text-gray-900 text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 block w-full p-2.5">
                        </div>
                        <div>
                            <label class="block text-sm font-medium text-white mb-2">Modulus (P):</label>
                            <input type="number" id="modulus" value="33" 
                                   class="bg-gray-50 border border-gray-300 text-gray-900 text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 block w-full p-2.5">
                        </div>
                        <div>
                            <label class="block text-sm font-medium text-white mb-2">Exponent (k):</label>
                            <input type="number" id="exponent" value="7" 
                                   class="bg-gray-50 border border-gray-300 text-gray-900 text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 block w-full p-2.5">
                        </div>
                    </div>
                `;
            }
        }

        document.getElementById('encryptionMethod').addEventListener('change', updateParameters);

        function caesarCipher(text, shift) {
            const alphabet = 'abcdefghijklmnopqrstuvwxyz';
            return text.toLowerCase().split('').map(char => {
                const idx = alphabet.indexOf(char);
                if (idx === -1) return char;
                return alphabet[(idx + shift) % alphabet.length];
            }).join('');
        }
        
        function modExpCipher(text, base, exponent, modulus) {
            const alphabet = 'abcdefghijklmnopqrstuvwxyz';
            return text.toLowerCase().split('').map(char => {
                const idx = alphabet.indexOf(char);
                if (idx === -1) return char;
                
                // Cifratura RSA: C = P^k mod N
                const encrypted = modPow(idx, exponent, modulus);
                
                console.log(`Char: ${char}, Index: ${idx}, Encrypted: ${encrypted}`);
                
                return encrypted.toString();
            }).join(' ');
        }

        function decryptModExp(text, base, exponent, modulus) {
            const alphabet = 'abcdefghijklmnopqrstuvwxyz';
            const invExponent = modInverse(exponent, (modulus-1));
            
            console.log(`Inverse Exponent: ${invExponent}`);

            return text.split(' ').map(char => {
                if (char === '') return ' ';
                
                const num = parseInt(char, 10);
                if (isNaN(num)) return char;
                
                // Decifratura RSA
                let decrypted = modPow(num, invExponent, modulus);
                
                // Mappiamo il valore decifrato all'intervallo 0-25
                let alphabetIndex = decrypted % alphabet.length;
                
                console.log(`Encrypted: ${num}, Decrypted: ${decrypted}, AlphabetIndex: ${alphabetIndex}`);
                
                return alphabet[alphabetIndex];
            }).join('');
        }

        const sampleTexts = [
            {
                title: "Shakespeare's Sonnet",
                text: "Shall I compare thee to a summer's day? Thou art more lovely and more temperate. Rough winds do shake the darling buds of May, And summer's lease hath all too short a date. Sometime too hot the eye of heaven shines, And often is his gold complexion dimmed; And every fair from fair sometime declines, By chance, or nature's changing course, untrimmed."
            },
            {
                title: "Scientific Statement",
                text: "The human brain is the most complex organ in the known universe. It contains approximately 86 billion neurons connected by trillions of synapses. Every thought, emotion, and action we experience emerges from the coordinated activity of these neural networks. Scientists continue to discover new aspects of brain function and organization through advanced imaging techniques and experimental studies."
            },
            {
                title: "Technology Article",
                text: "Artificial Intelligence has transformed the way we interact with technology. Machine learning algorithms now power everything from recommendation systems to autonomous vehicles. The rapid advancement of AI capabilities has sparked discussions about ethics, privacy, and the future of human work. As these systems become more sophisticated, the boundary between human and machine intelligence continues to evolve."
            },
            {
                title: "Nature Description",
                text: "The ancient redwood forest stood silent in the morning mist. Towering trees reached skyward, their branches creating a cathedral-like canopy hundreds of feet above. Soft moss carpeted the forest floor, punctuated by clusters of wild mushrooms and delicate ferns. The air was rich with the scent of damp earth and pine needles, carrying the whispers of countless generations of natural history."
            }
        ];

        function initializeWithRandomText() {
            const randomIndex = Math.floor(Math.random() * sampleTexts.length);
            const selectedText = sampleTexts[randomIndex];
            const textarea = document.getElementById('originalText');
            textarea.value = selectedText.text;
            
            // Aggiunge un menu a tendina per selezionare il testo
            const selectContainer = document.createElement('div');
            
            const label = document.createElement('label');
            label.className = 'block text-sm font-medium text-white mb-2';
            label.textContent = 'Select Sample Text or Write Your Own:';
            
            const select = document.createElement('select');
            select.className = 'bg-gray-50 border border-gray-300 text-blue-600 text-sm rounded-lg focus:ring-white focus:border-white block w-full p-2.5';
            select.onchange = function() {
                const selectedText = sampleTexts[this.value];
                textarea.value = selectedText.text;
                // Chiamata automatica all'analisi quando viene selezionato un nuovo testo
                processText();
            };
            
            sampleTexts.forEach((text, index) => {
                const option = document.createElement('option');
                option.value = index;
                option.text = text.title;
                option.selected = index === randomIndex;
                select.appendChild(option);
            });
            
            selectContainer.appendChild(label);
            selectContainer.appendChild(select);
            textarea.parentNode.insertBefore(selectContainer, textarea);
        }

        function getSymbolFrequency(text, cipherType) {
            const frequency = {};
            
            // Pulizia del testo a seconda del tipo di cifratura
            let cleanText;
            if (cipherType === 'caesar') {
                // Solo lettere dell'alfabeto (inclusi accenti)
                cleanText = text.toLowerCase().replace(/[^a-zàèéìòóù]/g, '');
            } else if (cipherType === 'modexp') {
                // Conserva solo caratteri validi (alfanumerici e simboli da cifratura modulare)
                cleanText = text.toLowerCase().replace(/[^a-z0-9]/g, '');
            } else {
                throw new Error("Unsupported cipherType. Use 'caesar' or 'modexp'.");
            }

            // Calcola la frequenza
            for (let char of cleanText) {
                frequency[char] = (frequency[char] || 0) + 1;
            }

            // Calcola le percentuali
            const total = cleanText.length;
            const percentages = {};
            for (let char in frequency) {
                percentages[char] = parseFloat(((frequency[char] / total) * 100).toFixed(2));
            }

            return percentages;
        }

        function createFrequencyChart(frequencies, canvasId, label, cipherType, modulus, base) {
            const ctx = document.getElementById(canvasId).getContext('2d');

            // Controllo: Frequenze vuote
            if (!frequencies || Object.keys(frequencies).length === 0) {
                new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: [],
                        datasets: [{
                            label: label,
                            data: [],
                            backgroundColor: 'rgba(255, 255, 255, 0.5)',
                            borderColor: 'rgb(255, 255, 255)',
                            borderWidth: 1
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            title: {
                                display: true,
                                text: 'No frequency data available',
                                padding: {
                                    top: 5,
                                    bottom: 30
                                }
                            },
                            legend: {
                                display: false
                            }
                        },
                        scales: {
                            x: {
                                display: false
                            },
                            y: {
                                display: false
                            }
                        }
                    }
                });
                return;
            }

            // Ordina le frequenze per valore decrescente
            const sortedFreqEntries = Object.entries(frequencies).sort((a, b) => b[1] - a[1]);
            const mostFrequentChar = sortedFreqEntries[0];

            let subtitleText = `Most frequent: '${mostFrequentChar[0]}'`;

            // Solo per il cifrario di Cesare, calcola la posizione alfabetica
            if (cipherType === 'caesar') {
                const alphabet = 'abcdefghijklmnopqrstuvwxyz';
                const charPosition = alphabet.indexOf(mostFrequentChar[0].toLowerCase()) + 1;
                if (charPosition > 0) {
                    subtitleText += ` (#${charPosition})`;
                }
            }

            // Per il cifrario modulare, aggiungi informazioni sul dominio
            if (cipherType === 'modexp' && modulus && base) {
                subtitleText += ` | Modulus: ${modulus}, Base: ${base}`;
            }

            // Ordina alfabeticamente per visualizzazione
            const sortedEntries = Object.entries(frequencies).sort((a, b) => a[0].localeCompare(b[0]));

            // Crea il grafico
            new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: sortedEntries.map(entry => entry[0]),
                    datasets: [{
                        label: label,
                        data: sortedEntries.map(entry => entry[1]),
                        backgroundColor: 'rgba(255, 255, 255, 0.5)',
                        borderColor: 'rgb(255, 255, 255)',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: 'Character Frequency Distribution [' + subtitleText + ']',
                            padding: {
                                top: 5,
                                bottom: 30
                            }
                        },
                        legend: {
                            display: false
                        },
                        tooltip: {
                            enabled: true
                        },
                        datalabels: {
                            anchor: 'end',
                            align: 'top',
                            formatter: value => value,
                            font: {
                                weight: 'semibold'
                            }
                        }
                    },
                    scales: {
                        x: {
                            barPercentage: 0.3,
                            categoryPercentage: 0.5,
                            title: {
                                display: true,
                                text: 'Characters or Numbers'
                            }
                        },
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Frequency (%)'
                            }
                        }
                    }
                },
                plugins: [ChartDataLabels]
            });
        }

        function findMostLikelyShift(originalFreq, encryptedFreq) {
            const englishFrequencies = {
                'e': 12.02, 't': 9.10, 'a': 8.12, 'o': 7.68, 'i': 7.31,
                'n': 6.95, 's': 6.28, 'r': 6.02, 'h': 5.92, 'd': 4.32,
                'l': 3.98, 'u': 2.88, 'c': 2.71, 'm': 2.61, 'f': 2.30,
                'y': 2.11, 'w': 2.09, 'g': 2.03, 'p': 1.82, 'b': 1.49,
                'v': 1.11, 'k': 0.69, 'x': 0.17, 'q': 0.11, 'j': 0.10, 'z': 0.07
            };

            const encryptedSorted = Object.entries(encryptedFreq).sort((a, b) => b[1] - a[1]);
            const englishSorted = Object.entries(englishFrequencies).sort((a, b) => b[1] - a[1]);
            
            // Ipotizza che la lettera più frequente nel testo cifrato corrisponda alla 'e'
            const mostFrequentEncrypted = encryptedSorted[0][0];
            const expectedChar = 'e';  // 'e' è la lettera più frequente in inglese
            
            const alphabet = 'abcdefghijklmnopqrstuvwxyz';
            const shift = (alphabet.indexOf(mostFrequentEncrypted) - alphabet.indexOf(expectedChar) + alphabet.length) % alphabet.length;
            
            return shift;
        }

        function animateCipher(originalText, encryptedText, elementId, method, params) {
            const container = document.getElementById(elementId);
            container.innerHTML = '';
            
            const animationContainer = document.createElement('div');
            animationContainer.className = 'font-mono relative p-4 bg-gray-50 rounded-md';
            
            const methodIndicator = document.createElement('div');
            methodIndicator.className = 'absolute top-2 right-2 bg-red-500 text-white px-2 py-1 rounded-md text-sm';
            
            if (method === 'caesar') {
                methodIndicator.textContent = `Shift: ${params.shift}`;
            } else {
                methodIndicator.textContent = `N=${params.base}, k=${params.exponent}, P=${params.modulus}`;
            }
            
            animationContainer.appendChild(methodIndicator);
            
            const textContainer = document.createElement('div');
            textContainer.className = 'break-words mt-8';
            animationContainer.appendChild(textContainer);
            
            container.appendChild(animationContainer);

            const chars = originalText.split('');
            textContainer.innerHTML = chars.map(char => `<span class="inline-block">${char}</span>`).join('');
            const charSpans = textContainer.querySelectorAll('span');
            
            let currentIndex = 0;

            function transformChar() {
                if (currentIndex < chars.length) {
                    const charSpan = charSpans[currentIndex];
                    const encryptedChar = method === 'caesar' ? 
                        encryptedText[currentIndex] :
                        encryptedText.split(' ')[currentIndex] || ' ';
                    
                    charSpan.className = 'inline-block transition-all duration-300 ease-in-out text-red-500 bg-red-100';
                    setTimeout(() => {
                        charSpan.className = 'inline-block transition-all duration-300 ease-in-out transform scale-125';
                        charSpan.textContent = encryptedChar;
                        setTimeout(() => {
                            charSpan.className = 'inline-block transition-all duration-300 ease-in-out text-gray-700';
                        }, 150);
                    }, 150);

                    currentIndex++;
                    setTimeout(transformChar, 25);
                } else {
                    setTimeout(() => {
                        textContainer.innerHTML = '';
                        textContainer.textContent = encryptedText;
                        textContainer.className = 'text-red-600 mt-8';
                        const encryptedFreq = getSymbolFrequency(encryptedText, method);
                        Chart.getChart('encryptedChart')?.destroy();
                        createFrequencyChart(encryptedFreq, 'encryptedChart', 'Letter Frequency (Encrypted Text)', method, params.modulus, params.base);
                        
                        // Start decryption animation
                        if (method === 'caesar') {
                            animateDecipher(encryptedText, originalText, 'decryptedText', {
                                method: 'caesar',
                                shift: 26 - params.shift
                            });
                        } else {
                            const decryptedText = decryptModExp(encryptedText, params.base, params.exponent, params.modulus);
                            animateDecipher(encryptedText, decryptedText, 'decryptedText', {
                                method: 'modexp',
                                base: params.base,
                                exponent: params.exponent,
                                modulus: params.modulus
                            });
                        }
                    }, 200);
                }
            }
            
            setTimeout(transformChar, 1000);
        }

        function processText() {
            Chart.getChart('originalChart')?.destroy();
            Chart.getChart('encryptedChart')?.destroy();
            document.getElementById('decryptedText').innerHTML = '';
            document.getElementById('encryptedText').innerHTML = '';

            const originalText = document.getElementById('originalText').value;
            const method = document.getElementById('encryptionMethod').value;

            // Analisi frequenza testo originale
            const originalFreq = getSymbolFrequency(originalText, method);
            createFrequencyChart(originalFreq, 'originalChart', 'Letter Frequency (Original Text)', method, null, null);

            let encryptedText, params;
            if (method === 'caesar') {
                const shift = parseInt(document.getElementById('shift').value) || 3;
                encryptedText = caesarCipher(originalText, shift);
                params = { shift };
            } else {
                const base = parseInt(document.getElementById('base').value) || 10;
                const exponent = parseInt(document.getElementById('exponent').value) || 7;
                const modulus = parseInt(document.getElementById('modulus').value) || 37;
                encryptedText = modExpCipher(originalText, base, exponent, modulus);
                params = { base, exponent, modulus };
            }

            animateCipher(originalText, encryptedText, 'encryptedText', method, params);
        }

        function animateDecipher(encryptedText, decryptedText, elementId, params) {
            const container = document.getElementById(elementId);
            container.innerHTML = '';

            const animationContainer = document.createElement('div');
            animationContainer.className = 'font-mono relative p-4 bg-gray-50 rounded-md';
            
            const methodIndicator = document.createElement('div');
            methodIndicator.className = 'absolute top-2 right-2 bg-green-500 text-white px-2 py-1 rounded-md text-sm';
            
            if (params.method === 'caesar') {
                methodIndicator.textContent = `Inverted shift: ${params.shift}`;
            } else {
                methodIndicator.textContent = `Decrypting with inverse exponent`;
            }
            
            animationContainer.appendChild(methodIndicator);
            
            const textContainer = document.createElement('div');
            textContainer.className = 'break-words mt-8';
            animationContainer.appendChild(textContainer);
            
            container.appendChild(animationContainer);

            const encryptedChars = params.method === 'caesar' ? 
                encryptedText.split('') : 
                encryptedText.split(' ');
            
            textContainer.innerHTML = encryptedChars.map(char => 
                `<span class="inline-block">${char}</span>`
            ).join(params.method === 'caesar' ? '' : ' ');
            
            const charSpans = textContainer.querySelectorAll('span');
            let currentIndex = encryptedChars.length - 1;

            function transformChar() {
                if (currentIndex >= 0) {
                    const charSpan = charSpans[currentIndex];
                    const decryptedChar = params.method === 'caesar' ? 
                        decryptedText[currentIndex] : 
                        decryptedText[currentIndex];
                    
                    charSpan.className = 'inline-block transition-all duration-300 ease-in-out text-green-500 bg-green-100';
                    setTimeout(() => {
                        charSpan.className = 'inline-block transition-all duration-300 ease-in-out transform scale-125';
                        charSpan.textContent = decryptedChar;
                        setTimeout(() => {
                            charSpan.className = 'inline-block transition-all duration-300 ease-in-out text-gray-700';
                        }, 150);
                    }, 150);

                    currentIndex--;
                    setTimeout(transformChar, 25);
                } else {
                    setTimeout(() => {
                        textContainer.innerHTML = '';
                        textContainer.textContent = decryptedText;
                        textContainer.className = 'text-green-600 mt-8';
                    }, 200);
                }
            }
            
            setTimeout(transformChar, 1000);
        }

        // Initialize parameters on page load
        document.addEventListener('DOMContentLoaded', function() {
            updateParameters();
            initializeWithRandomText();
        });
    </script>
    <script src="background.js"></script>
</body>
</html>